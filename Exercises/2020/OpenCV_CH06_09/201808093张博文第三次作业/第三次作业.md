# 第三次作业
# 201808093


# 方框滤波：boxFilter函数的使用


1.第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。该函数对通道是独立处理的，且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。

2.第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。

3.第三个参数，int类型的ddepth，输出图像的深度，-1代表使用原图深度，即src.depth()。

4.第四个参数，Size类型的ksize，内核的大小。一般这样写Size( w,h )来表示内核的大小( 其中，w 为像素宽度， h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小

5.第五个参数，Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。

6.第六个参数，bool类型的normalize，默认值为true，一个标识符，表示内核是否被其区域归一化（normalized）了。

7.第七个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。

## 代码
//-----------------------------------【头文件包含部分】---------------------------------------

//     描述：包含程序所依赖的头文件

//----------------------------------------------------------------------------------------------
#include "opencv2/core/core.hpp"

#include"opencv2/highgui/highgui.hpp"

#include"opencv2/imgproc/imgproc.hpp"

//-----------------------------------【命名空间声明部分】---------------------------------------

//     描述：包含程序所使用的命名空间

//----------------------------------------------------------------------------------------------- 

using namespace cv;

//-----------------------------------【main( )函数】--------------------------------------------

//     描述：控制台应用程序的入口函数，我们的程序从这里开始

//-----------------------------------------------------------------------------------------------

int main()
{

    //载入原图
    Mat image = imread("2.png");

    //创建窗口
    namedWindow("均值滤波【原图】");
    namedWindow("均值滤波【效果图】");

    //显示原图
    imshow("均值滤波【原图】", image);

    //进行滤波操作
    Mat out;
    boxFilter(image, out, -1, Size(5, 5));

    //显示效果图
    imshow("均值滤波【效果图】", out);

    waitKey(0);
}
## 运行截图

![](picture/project31.png)

# 均值滤波：blur函数的使用
## 笔记
blur的作用是对输入的图像src进行均值滤波后用dst输出。
![](picture/blur函数.png)

参数详解如下：

1.第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。该函数对通道是独立处理的，且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。

2.第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。

3.第三个参数，Size类型（对Size类型稍后有讲解）的ksize，内核的大小。一般这样写Size( w,h )来表示内核的大小( 其中，w 为像素宽度， h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小
第四个参数，Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。
第五个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。

## 代码
#include"opencv2/core/core.hpp"

#include"opencv2/highgui/highgui.hpp"

#include"opencv2/imgproc/imgproc.hpp"
using namespace cv ;

int main()
{

	//载入原图
	Mat image = imread("1.jpg");
	//剑建窗口
	namedWindow("均值滤波【原图】"); 
	namedWindow("均值滤波【效果图】");
	//显示原图
	imshow("均值滤波【原图】", image);
	//进行滤波操作
		Mat out;
	blur(image,out,Size(7, 7));
	//显示效栗图
	imshow("均值滤波【效果图】", out);
	waitKey(0);
}

## 运行截图
![](picture/project32.png)

# 高斯滤波：GaussianBlur函数的使用
## 笔记
函数原型如下：
![](picture/高斯滤波.png)
参数详解如下：

1.第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。它可以是单独的任意通道数的图片，但需要注意，图片深度应该为CV_8U,CV_16U, CV_16S, CV_32F 以及 CV_64F之一。

2.第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。

3.第三个参数，Size类型的ksize高斯内核的大小。其中ksize.width和ksize.height可以不同，但他们都必须为正数和奇数。或者，它们可以是零的，它们都是由sigma计算而来。

4.第四个参数，double类型的sigmaX，表示高斯核函数在X方向的的标准偏差。

5.第五个参数，double类型的sigmaY，表示高斯核函数在Y方向的的标准偏差。若sigmaY为零，就将它设为sigmaX，如果sigmaX和sigmaY都是0，那么就由ksize.width和ksize.height计算出来。为了结果的正确性着想，最好是把第三个参数Size，第四个参数sigmaX和第五个参数sigmaY全部指定到。

6.第六个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。注意它有默认值BORDER_DEFAULT。
## 代码
#include"opencv2/core/core.hpp"

#include"opencv2/highgui/highgui.hpp"

#include"opencv2/imgproc/imgproc.hpp"
using namespace cv;

int main()
{

	//载入原图
	Mat image = imread("1.jpg");
	//剑建窗口
	namedWindow("高斯滤波【原图】");
	namedWindow("高斯滤波【效果图】");
	//显示原图
	imshow("高斯滤波【原图】", image);
	//进行高斯滤波操作
	Mat out;
	GaussianBlur(image, out, Size(7, 7), 0, 0);
	//显示效栗图
	imshow("高斯滤波【效果图】", out);
	waitKey(0);
}

## 运行结果
![](picture/project33.png)

# 综合示例：图像线性滤波
## 代码
#include <opencv2/opencv.hpp>

using namespace std;

using namespace cv;

//全局变量声明部分

Mat g_srcImage, g_dstImage1, g_dstImage2, g_dstImage3;//存储图片的Mat类型

int g_nBoxFilterValue = 3;//方框滤波参数值

int g_nMeanBlurValue = 3;//均值滤波参数值

int g_nGaussianBlurValue = 3;//高斯滤波参数值

//全局函数声明部分

static void on_BoxFilter(int, void*);

static void on_MeanBlur(int, void*);

static void on_GaussianBlur(int, void*);

//main()函数

int main() {

	//改变console字体颜色
	system("color5E");

	//载入原图
	g_srcImage = imread("1.jpg", 1);//载入三通道彩色图像
	if (!g_srcImage.data) {
		printf("读取srcImage错误！\n");
		return false;
	}

	//复制原图到三个Mat类型中
	g_dstImage1 = g_srcImage.clone();//初始化目标图像大小，类型
	g_dstImage2 = g_srcImage.clone();
	g_dstImage3 = g_srcImage.clone();

	//显示原图
	namedWindow("<0>原图窗口", 1);
	imshow("<0>原图窗口", g_srcImage);

	//====================【<1>方框滤波】=====================
	//创建窗口
	namedWindow("<1>方框滤波", 1);
	//创建轨迹条
	createTrackbar("内核值：", "<1>方框滤波", &g_nBoxFilterValue, 40, on_BoxFilter);
	on_BoxFilter(g_nBoxFilterValue, 0);//回调函数参数初始化
	//=========================================================

	//=====================【<2>均值滤波】=====================
	namedWindow("<2>均值滤波", 1);
	createTrackbar("内核值：", "<2>均值滤波", &g_nMeanBlurValue, 40, on_MeanBlur);
	on_MeanBlur(g_nMeanBlurValue, 0);
	//=========================================================

	//=====================【<3>高斯滤波】=====================
	namedWindow("<3>高斯滤波", 1);
	createTrackbar("内核值：", "<3>高斯滤波", &g_nGaussianBlurValue, 40, on_GaussianBlur);
	on_GaussianBlur(g_nGaussianBlurValue, 0);
	//=========================================================

	//输出一些帮助信息
	cout << endl << "\t,请调整轨迹条观察图像效果！\n\n" << "\t按下‘Q’键，程序退出！\n";
	//按下Q键程序退出
	while (char(waitKey(1)) != 'q') {}

	return 0;
}

//=======================【on_BoxFilter()函数】==============================

static void on_BoxFilter(int, void*) {

    //回调函数参数格式
	//方框滤波操作
	boxFilter(g_srcImage, g_dstImage1, -1, Size(g_nBoxFilterValue + 1, g_nBoxFilterValue + 1));//ddepth=1,dst为原图深
	//显示窗口
	imshow("<1>方框滤波", g_dstImage1);
}

//=======================【on_MeanBlur()函数】===============================
static void on_MeanBlur(int, void*) {

	blur(g_srcImage, g_dstImage2, Size(g_nMeanBlurValue + 1, g_nMeanBlurValue + 1), Point(-1, -1));
	imshow("<2>均值滤波", g_dstImage2);
}

//=======================【on_GaussianBlur()函数】===========================
static void on_GaussianBlur(int, void*) {

	GaussianBlur(g_srcImage, g_dstImage3, Size(g_nGaussianBlurValue * 2 + 1, g_nGaussianBlurValue * 2 + 1), 0, 0);
	imshow("<3>高斯滤波", g_dstImage3);
}

## 运行结果
![](picture/project34.png)

# 中值滤波：medianBlur函数的使用
## 笔记
函数原型：
<span style="background-color: rgb(255, 255, 255);"><strong><span style="font-size:18px;">C++: void medianBlur(InputArray src, OutputArray dst, int ksize)</span></strong></span>

 参数详解：

1.第一个参数，InputArray类型的src，函数的输入参数，填1、3或者4通道的Mat类型的图像；当ksize为3或者5的时候，图像深度需为CV_8U，CV_16U，或CV_32F其中之一，而对于较大孔径尺寸的图片，它只能是CV_8U。

2.第二个参数，OutputArray类型的dst，即目标图像，函数的输出参数，需要和源图片有一样的尺寸和类型。我们可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。

3.第三个参数，int类型的ksize，孔径的线性尺寸（aperture linear size），注意这个参数必须是大于1的奇数，比如：3，5，7，9 ...

4.中值滤波（Median filter）是一种典型的非线性滤波技术，基本思想是用像素点邻域灰度值的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像边缘细节。

5.中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，其基本原理是把数字图像或数字序列中一点的值用该点的一个邻域中各点值的中值代替，让周围的像素值接近的真实值，从而消除孤立的噪声点，对于斑点噪声（speckle noise）和椒盐噪声（salt-and-pepper noise）来说尤其有用，因为它不依赖于邻域内那些与典型值差别很大的值。中值滤波器在处理连续图像窗函数时与线性滤波器的工作方式类似，但滤波过程却不再是加权运算。

## 代码
#include"opencv2/core/core.hpp"

#include"opencv2/highgui/highgui.hpp"

#include"opencv2/imgproc/imgproc.hpp"

using namespace cv;

int main()
{

	//载入原图
	Mat image = imread("1.jpg");
	//剑建窗口
	namedWindow("中值滤波【原图】");
	namedWindow("中值滤波【效果图】");
	//显示原图
	imshow("中值滤波【原图】", image);
	//进行中值滤波操作
	Mat out;
	medianBlur(image, out,7);
	//显示效栗图
	imshow("中值滤波【效果图】", out);
	waitKey(0);
}

## 运行结果
![](picture/project35.png)

# 双边滤波：bilateralFilter函数的使用
## 笔记
函数原型：
C++: void bilateralFilter(InputArray src, OutputArraydst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT)  

1.第一个参数：InputArray类型的src，输入图像，即源图像，需要为8位或者浮点型单通道、三通道的图像。

2.第二个参数：OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。

3.第三个参数：int类型的d，表示在过滤过程中每个像素邻域的直径。如果这个值我们设其为非正数，那么OpenCV会从第五个参数sigmaSpace来计算出它来。

4.第四个参数：double类型的sigmaColor，颜色空间滤波器的sigma值。这个参数的值越大，就表明该像素邻域内有更宽广的颜色会被混合到一起，产生较大的半相等颜色区域。

5.第五个参数：double类型的sigmaSpace坐标空间中滤波器的sigma值，坐标空间的标注方差。他的数值越大，意味着越远的像素会相互影响，从而使更大的区域足够相似的颜色获取相同的颜色。当d>0，d指定了邻域大小且与sigmaSpace无关。否则，d正比于sigmaSpace。

6.第六个参数：int类型的borderType，用于推断图像外部像素的某种边界模式。注意它有默认值BORDER_DEFAULT。

## 代码
#include "opencv2/core/core.hpp"  
#include"opencv2/highgui/highgui.hpp"  
#include"opencv2/imgproc/imgproc.hpp"  
//-----------------------------------【命名空间声明部分】---------------------------------------  
//     描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------   
using namespace cv;

//-----------------------------------【main( )函数】--------------------------------------------  
//     描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原图  
    Mat image = imread("1.jpg");

    //创建窗口  
    namedWindow("双边滤波【原图】");
    namedWindow("双边滤波【效果图】");

    //显示原图  
    imshow("双边滤波【原图】", image);

    //进行双边滤波操作  
    Mat out;
    bilateralFilter(image, out, 25, 25 * 2, 25 / 2);

    //显示效果图  
    imshow("双边滤波【效果图】", out);

    waitKey(0);
}

## 运行结果
![](picture/project36.png)

# 综合示例：图像滤波

## 代码

#include <opencv2/core/core.hpp>

#include <opencv2/highgui/highgui.hpp>

#include <opencv2/imgproc/imgproc.hpp>

#include "iostream"

using namespace std;

using namespace cv;

Mat g_srcImage,g_dstImage1,g_dstImage2,g_dstImage3,g_dstImage4,g_dstImage5;

int g_nBoxFilterValue=6;  //方框滤波内核值

int g_nMeanBlurValue=10;  //均值滤波内核值

int g_nGaussianBlurValue=6;  //高斯滤波内核值

int g_nMedianBlurValue=10;  //中值滤波参数值

int g_nBilateralFilterValue=10;  //双边滤波参数值

//轨迹条回调函数

static void on_BoxFilter(int, void *);          //方框滤波器

static void on_MeanBlur(int, void *);           //均值滤波器

static void on_GaussianBlur(int, void *);       //高斯滤波器

static void on_MedianBlur(int, void *);         //中值滤波器

static void on_BilateralFilter(int, void *);    //双边滤波器

int main(   )
{

    g_srcImage = imread( "1.jpg", 1 );
    if( !g_srcImage.data ) { printf("读取srcImage错误~！ \n"); return false; }

    //克隆原图到四个Mat类型中
    g_dstImage1 = g_srcImage.clone( );
    g_dstImage2 = g_srcImage.clone( );
    g_dstImage3 = g_srcImage.clone( );
    g_dstImage4 = g_srcImage.clone( );
    g_dstImage5 = g_srcImage.clone( );

    //显示原图
    namedWindow("【<0>原图窗口】", 1);
    imshow("【<0>原图窗口】",g_srcImage);

    //=================【<1>方框滤波】=========================
    //创建窗口
    namedWindow("【<1>方框滤波】", 1);
    //创建轨迹条
    createTrackbar("内核值：", "【<1>方框滤波】",&g_nBoxFilterValue, 50,on_BoxFilter );
    on_MeanBlur(g_nBoxFilterValue,0);
    imshow("【<1>方框滤波】", g_dstImage1);

    //=================【<2>均值滤波】==========================
    //创建窗口
    namedWindow("【<2>均值滤波】", 1);
    //创建轨迹条
    createTrackbar("内核值：", "【<2>均值滤波】",&g_nMeanBlurValue, 50,on_MeanBlur );
    on_MeanBlur(g_nMeanBlurValue,0);

    //=================【<3>高斯滤波】===========================
    //创建窗口
    namedWindow("【<3>高斯滤波】", 1);
    //创建轨迹条
    createTrackbar("内核值：", "【<3>高斯滤波】",&g_nGaussianBlurValue, 50,on_GaussianBlur );
    on_GaussianBlur(g_nGaussianBlurValue,0);

    //=================【<4>中值滤波】===========================
    //创建窗口
    namedWindow("【<4>中值滤波】", 1);
    //创建轨迹条
    createTrackbar("参数值：", "【<4>中值滤波】",&g_nMedianBlurValue, 50,on_MedianBlur );
    on_MedianBlur(g_nMedianBlurValue,0);

    //=================【<5>双边滤波】===========================
    //创建窗口
    namedWindow("【<5>双边滤波】", 1);
    //创建轨迹条
    createTrackbar("参数值：", "【<5>双边滤波】",&g_nBilateralFilterValue, 50,on_BilateralFilter);
    on_BilateralFilter(g_nBilateralFilterValue,0);

    cout<<endl<<"\t运行成功，请调整滚动条观察图像效果~\n\n"<<"\t按下“q”键时，程序退出。\n";
    while(char(waitKey(1)) != 'q') {}
    return 0;
}

static void on_BoxFilter(int, void *)
{

    boxFilter( g_srcImage, g_dstImage1, -1,Size( g_nBoxFilterValue+1, g_nBoxFilterValue+1));

    imshow("【<1>方框滤波】", g_dstImage1);
}

static void on_MeanBlur(int, void *)
{

    blur( g_srcImage, g_dstImage2, Size( g_nMeanBlurValue+1, g_nMeanBlurValue+1), Point(-1,-1));

    imshow("【<2>均值滤波】", g_dstImage2);
}

static void on_GaussianBlur(int, void *)
{

    GaussianBlur( g_srcImage, g_dstImage3, Size( g_nGaussianBlurValue*2+1, g_nGaussianBlurValue*2+1 ), 0, 0);

    imshow("【<3>高斯滤波】", g_dstImage3);
}

static void on_MedianBlur(int, void *)
{

    medianBlur ( g_srcImage, g_dstImage4, g_nMedianBlurValue*2+1 );

    imshow("【<4>中值滤波】", g_dstImage4);
}

static void on_BilateralFilter(int, void *)
{

    bilateralFilter ( g_srcImage, g_dstImage5, g_nBilateralFilterValue,g_nBilateralFilterValue*2, g_nBilateralFilterValue/2 );

    imshow("【<5>双边滤波】", g_dstImage5);
}

## 运行结果
![](picture/project37-1.png)
![](picture/project37-2.png)

# 膨胀：dilate函数的使用
## 笔记
dilate函数使用像素邻域内的局部极大运算符来膨胀一张图片，从src输入，由dst输出。支持就地( in-place）操作。

函数原型

![](picture/dilate函数原型.png)

参数详解如下。
1.第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。图像通道的数量可以是任意的,但图像深度应为CV_8u.cv_16U、cV_16S、cV_32F或CV_64F其中之一。

2.第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。

3.第三个参数，InputArray类型的kernel，膨胀操作的核。当为NULL时，表示的是使用参考点位于中心3×3的核。

我们一般使用函数getStructuringElement配合这个参数的使用。getStructuringElement函数会返回指定形状和尺寸的结构元素（内核矩阵)。其中，getStructuringElement 函数的第一个参数表示内核的形状，有如下三种形状可以选择。

矩形:MORPH_RECT;

交叉形:MORPH_CROSs;

椭圆形: MORPH_ELLIPSE。

而getStructuringElement函数的第二和第三个参数分别是内核的尺寸以及锚点的位置。

一般在调用erode 以及 dilate函数之前，先定义一个 Mat类型的变量来获得getStructuringElement 函数的返回值。对于锚点的位置，有默认值Point(-1,-1)，表示锚点位于中心。此外，需要注意，十字形的 element形状唯一依赖于锚点的位置，而在其他情况下，锚点只是影响了形态学运算结果的偏移。

getStructuringElement函数相关的调用示例代码如下。

![](picture/getStructuringElement函数.png)


调用之后，我们可以在接下来调用erode或dilate函数时，在第三个参数填保存了getStructuringElement返回值的Mat类型变量。对应于上面的示例，就是element变量。

4.第四个参数，Point类型的 anchor，锚的位置，其有默认值(-1,-1)，表示锚位于中心。

5.第五个参数，int类型的 iterations，迭代使用erode()函数的次数，默认值为1。

6.第六个参数，int类型的 borderType，用于推断图像外部像素的某种边界模式。注意它有默认值BORDER_DEFAULT。

7·第七个参数，const Scalar&类型的 borderValue，当边界为常数时的边界值，有默认值morphologyDefaultBorderValue()，一般不用去管它。需要用到它时，可以看官方文档中的createMorphologyFilter()函数，以得到更详细的解释。

使用erode 函数，一般只需要填前面的三个参数，后面的四个参数都有默认值，而且往往会结合getStructuringElement一起使用。


## 代码
// ----------------------【头文件、命名空间包含部分】----------

//            描述:包含程序所依赖的头文件和命名空间

// ------------------------------------------------------------

#include <opencv2/core/core.hpp>

#include<opencv2/highgui/highgui.hpp>

#include<opencv2/imgproc/imgproc.hpp>

#include <iostream>

//------------------------ - 【命名空间声明部分】--------------

//       描述:包含程序所使用的命名空间

//-------------------------------------------------------------

using namespace std;

using namespace cv;

//--------------------------[main()函数】----------------------

//描述:控制台应用程序的入口函数，我们的程序从这里开始

// ------------------------------------------------------------

int main()
{

      //裁入原图
      Mat image = imread("1.jPg");

     //创建窗口
      namedWindow("【原图】膨胀操作");
      namedWindow("【效果图】膨胀操作");

	 //显示原图
	 imshow("【原图】膨胀操作", image);

	 //获取自定义核
     Mat element = getStructuringElement(MORPH_RECT, Size(15,15));
     Mat out;

     //进行膨胀操作
     dilate(image, out, element);

     //显示效果图
     imshow("【效果图】膨胀操作", out);

	 waitKey(0);
     return 0;
}

## 运行结果
![](picture/project38.png)

# 腐蚀：erode函数的使用
## 笔记
erode函数使用像素邻域内的局部极小运算符来腐蚀一张图片，从 src输入，由dst输出。支持就地（ in-place）操作。

函数原型

![](picture/erode函数.png)

1.第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。图像通道的数量可以是任意的,但图像深度应为CV_8U.CV_16U、cV_16S、cV_32F或cV_64F其中之一。

2·第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。

3·第三个参数，InputArray类型的kernel，腐蚀操作的内核。为NULL时，表示的是使用参考点位于中心3x3的核。一般使用函数getStructuringElement配合这个参数的使用。getStructuringElement函数会返回指定形状和尺寸的结构元素（内核矩阵，具体看上文中dilate函数的第三个参数讲解部分。

4·第四个参数，Point类型的anchor，错的位置。其有默认值(-1,-1)，表示错位于单位(element）的中心，一般不用管它。

5·第五个参数，int类型的 iterations，迭代使用erode()函数的次数，默认值为1。

6·第六个参数，int类型的 borderType，用于推断图像外部像素的某种边界模式。注意它有默认值 BORDER_DEFAULT。

7·第七个参数，const Scalar&类型的 borderValue，当边界为常数时的边界值，有默认值 morphologyDefaultBorderValue()，一般不用去管它。需要用到它时，可以看官方文档中的createMorphologyFilter()函数以得到更详细的解释。

同样的，使用erode 函数，一般只需要填前面的三个参数，后面的四个参数都有默认值。而且往往结合getStructuringElement一起使用。

## 代码
// ----------------------【头文件、命名空间包含部分】----------

//            描述:包含程序所依赖的头文件和命名空间

// ------------------------------------------------------------

#include <opencv2/core/core.hpp>

#include<opencv2/highgui/highgui.hpp>

#include<opencv2/imgproc/imgproc.hpp>

#include <iostream>

//-------------------------【命名空间声明部分】--------------

//       描述:包含程序所使用的命名空间

//-------------------------------------------------------------

using namespace std;

using namespace cv;

//--------------------------【main()函数】----------------------

//描述:控制台应用程序的入口函数，我们的程序从这里开始

// ------------------------------------------------------------

int main()
{

    //裁入原图
    Mat image = imread("1.jPg");

    //创建窗口
    namedWindow("【原图】腐蚀操作");
    namedWindow("【效果图】腐蚀操作");

    //显示原图
    imshow("【原图】腐蚀操作", image);

    //获取自定义核
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    Mat out;

    //进行腐蚀操作
    erode(image, out, element);

    //显示效果图
    imshow("【效果图】腐蚀操作", out);

    waitKey(0);
    return 0;
}

## 运行结果
![](picture/project39.png)

# 综合示例：腐蚀与膨胀
## 代码
//-----------------------------------【头文件包含部分】---------------------------------------

//            描述：包含程序所依赖的头文件

//------------------------------------------------------------------------------------------
#include <opencv2/opencv.hpp>

#include <opencv2/highgui/highgui.hpp>

#include<opencv2/imgproc/imgproc.hpp>

#include <iostream>

//-----------------------------------【命名空间声明部分】---------------------------------------

//            描述：包含程序所使用的命名空间

//--------------------------------------------------------------------------------------------

using namespace std
;
using namespace cv;

//-----------------------------------【全局变量声明部分】--------------------------------------

//            描述：全局变量声明

//-------------------------------------------------------------------------------------------

Mat g_srcImage, g_dstImage;//原始图和效果图

int g_nTrackbarNumer = 0;//0表示腐蚀erode, 1表示膨胀dilate

int g_nStructElementSize = 3; //结构元素(内核矩阵)的尺寸


//-----------------------------------【全局函数声明部分】--------------------------------------

//            描述：全局函数声明

//-------------------------------------------------------------------------------------------

void Process();//膨胀和腐蚀的处理函数

void on_TrackbarNumChange(int, void*);//回调函数

void on_ElementSizeChange(int, void*);//回调函数


//-----------------------------------【main( )函数】------------------------------------------

//            描述：控制台应用程序的入口函数，我们的程序从这里开始

//-------------------------------------------------------------------------------------------
int main()

{

    //改变console字体颜色
    system("color5E");

    //载入原图
    g_srcImage = imread("1.jpg");
    if (!g_srcImage.data) { printf("Oh，no，读取srcImage错误~！\n"); return false; }

    //显示原始图
    namedWindow("【原始图】");
    imshow("【原始图】", g_srcImage);

    //进行初次腐蚀操作并显示效果图
    namedWindow("【效果图】");
    //获取自定义核
    Mat element = getStructuringElement(MORPH_RECT, Size(2 * g_nStructElementSize + 1, 2 * g_nStructElementSize + 1), Point(g_nStructElementSize, g_nStructElementSize));
    erode(g_srcImage, g_dstImage, element);
    imshow("【效果图】", g_dstImage);

    //创建轨迹条
    createTrackbar("腐蚀/膨胀", "【效果图】", &g_nTrackbarNumer, 1, on_TrackbarNumChange);
    createTrackbar("内核尺寸", "【效果图】", &g_nStructElementSize, 21, on_ElementSizeChange);

   
    //轮询获取按键信息，若下q键，程序退出
    while (char(waitKey(1)) != 'q') {}

    return 0;
}

//-----------------------------【Process( )函数】------------------------------------

//            描述：进行自定义的腐蚀和膨胀操作

//-----------------------------------------------------------------------------------

void Process()
{

    //获取自定义核
    Mat element = getStructuringElement(MORPH_RECT, Size(2 * g_nStructElementSize + 1, 2 * g_nStructElementSize + 1), Point(g_nStructElementSize, g_nStructElementSize));

    //进行腐蚀或膨胀操作
    if (g_nTrackbarNumer == 0) {
        erode(g_srcImage, g_dstImage, element);
    }
    else {
        dilate(g_srcImage, g_dstImage, element);
    }

    //显示效果图
    imshow("【效果图】", g_dstImage);
}


//-----------------------------【on_TrackbarNumChange( )函数】---------------------------------

//            描述：腐蚀和膨胀之间切换开关的回调函数

//--------------------------------------------------------------------------------------------

void on_TrackbarNumChange(int, void*)
{

	 //腐蚀和膨胀之间效果已经切换，回调函数体内需调用一次Process函数，使改变后的效果立即生效并显示出来
    Process();
}


//-----------------------------【on_ElementSizeChange( )函数】--------------------------------

//            描述：腐蚀和膨胀操作内核改变时的回调函数

//-------------------------------------------------------------------------------------------

void on_ElementSizeChange(int, void*)
{

    //内核尺寸已改变，回调函数体内需调用一次Process函数，使改变后的效果立即生效并显示出来
    Process();
}
## 运行结果
![](picture/project40-1.png)
![](picture/project40-2.png)

# morphologyEX()函数
## 笔记
![](picture/morphologyEX()函数.png)
1.第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。图像位深应该为以下五种之一：CV_8U, CV_16U,CV_16S, CV_32F 或CV_64F。

2.第二个参数，OutputArray类型的dst，即目标图像，函数的输出参数，需要和源图片有一样的尺寸和类型。

3.第三个参数，int类型的op，表示形态学运算的类型，可以是如下之一的标识符：

 MORPH_OPEN – 开运算（Opening operation）
 MORPH_CLOSE – 闭运算（Closing operation）
 MORPH_GRADIENT -形态学梯度（Morphological gradient）
 MORPH_TOPHAT - “顶帽”（“Top hat”）
 MORPH_BLACKHAT - “黑帽”（“Black hat“）

4.第四个参数，InputArray类型的kernel，形态学运算的内核。若为NULL时，表示的是使用参考点位于中心3x3的核。我们一般使用函数 getStructuringElement配合这个参数的使用。getStructuringElement函数会返回指定形状和尺寸的结构元素（内核矩阵）

其中，getStructuringElement函数的第一个参数表示内核的形状，我们可以选择如下三种形状之一:

矩形: MORPH_RECT

交叉形: MORPH_CROSS

椭圆形: MORPH_ELLIPSE

而getStructuringElement函数的第二和第三个参数分别是内核的尺寸以及锚点的位置。

我们一般在调用erode以及dilate函数之前，先定义一个Mat类型的变量来获得getStructuringElement函数的返回值。对于锚点的位置，有默认值Point(-1,-1)，表示锚点位于中心。且需要注意，十字形的element形状唯一依赖于锚点的位置。而在其他情况下，锚点只是影响了形态学运算结果的偏移。

5.第五个参数，Point类型的anchor，锚的位置，其有默认值（-1，-1），表示锚位于中心。
            
6.第六个参数，int类型的iterations，迭代使用函数的次数，默认值为1。

7.第七个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。注意它有默认值BORDER_ CONSTANT。

8.第八个参数，const Scalar&类型的borderValue，当边界为常数时的边界值，有默认值morphologyDefaultBorderValue()，一般我们不用去管他。需要用到它时，可以看官方文档中的createMorphologyFilter()函数得到更详细的解释。


## 用morphologyEX()函数实现形态学膨胀
### 笔记
膨胀：用结构元素的中心点对准当前正在遍历的这个像素，
然后取当前结构元素所覆盖下的原图对应区域内的所有像素的最大值，用这个最大值替换当前像素值，给图像中的对象边界添加像素，使二值图像扩大一圈
1. 用结构元素，扫描图像的每一个像素
2. 用结构元素与其覆盖的二值图像做“与”操作
3. 如果都为0，结果图像的该像素为0。否则为1
也就是在结构元素覆盖范围下，只要有一个像素符和结构元素像素相同，那么中心点对应点就为1，否则为0
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_DILATE, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project41.png)

## 用morphologyEX()函数实现形态学腐蚀
### 笔记
腐蚀：用结构元素的中心点对准当前正在遍历的这个像素，
然后取当前结构元素所覆盖下的原图对应区域内的所有像素的最小值，用这个最小值替换当前像素值，删除对象边界的某些像素，使二值图像减小一圈
1. 用结构元素，扫描图像的每一个像素
2. 用结构元素与其覆盖的二值图像做“与”操作
3. 如果都为1，结果图像的该像素为1。否则为0
也就是查找被处理图像中能不能找到和结构元素相同的矩阵。如果存在那么中心点所对应的点就为1，否则为0
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_ERODE, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project42.png)

## 用morphologyEX()函数实现形态学开运算
### 笔记
开运算：先腐蚀，再膨胀，可清除一些小东西(亮的)，放大局部低亮度的区域 
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_OPEN, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project43.png)

## 用morphologyEX()函数实现形态学闭运算
### 笔记
闭运算：先膨胀，再腐蚀，可清除小黑点 
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_CLOSE, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project44.png)

## 用morphologyEX()函数实现形态学梯度
### 笔记
形态学梯度：膨胀图与腐蚀图之差，提取物体边缘 
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_GRADIENT, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project45.png)

## 用morphologyEX()函数实现形态学“顶帽”
### 笔记
顶帽：原图像-开运算图，突出原图像中比周围亮的区域 
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_TOPHAT, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project46.png)

## 用morphologyEX()函数实现形态学“黑帽”
### 笔记
黑帽：闭运算图-原图像，突出原图像中比周围暗的区域
### 代码
//-----------------------------------【头文件包含部分】---------------------------------------  
//            描述：包含程序所依赖的头文件  
//----------------------------------------------------------------------------------------------  
#include <opencv2/opencv.hpp>  
#include<opencv2/highgui/highgui.hpp>  
#include<opencv2/imgproc/imgproc.hpp>  

//-----------------------------------【命名空间声明部分】---------------------------------------  
//            描述：包含程序所使用的命名空间  
//-----------------------------------------------------------------------------------------------  
using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------  
//            描述：控制台应用程序的入口函数，我们的程序从这里开始  
//-----------------------------------------------------------------------------------------------  
int main()
{

    //载入原始图    
    Mat image = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图  
    //创建窗口    
    namedWindow("【原始图】膨胀");
    namedWindow("【效果图】膨胀");
    //显示原始图   
    imshow("【原始图】膨胀", image);
    //定义核  
    Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));
    //进行形态学操作  
    morphologyEx(image, image, MORPH_BLACKHAT, element);
    //显示效果图   
    imshow("【效果图】膨胀", image);

    waitKey(0);
    return 0;
}
### 运行结果
![](picture/project47.png)

## 注：这些代码基本上内容一致，就是改一下morphologyEx里面的第三个标识符参数。核都是选的MORPH_RECT（矩形元素结构)。

# 综合示例：形态学滤波

## 代码
#include <opencv2/opencv.hpp>

#include <opencv2/highgui/highgui.hpp>

#include <opencv2/imgproc/imgproc.hpp>

using namespace std;

using namespace cv;

//----------------------【全局变量声明部分】-----------------

//描述：全部变量声明

//--------------------------------------------------------

Mat g_srcImage, g_dstImage;         //原始图和效果图

int g_nElementShape = MORPH_RECT;   //元素结构形状

//变量接受TrackBar位置参数

int g_nMaxIterationNum = 10;

int g_nOpenCloseNum = 0;

int g_nErodeDilateNum = 0;

int g_nTopBlackHatNum = 2;

//-------------------------【全局函数声明部分】--------------

//  描述：全局函数声明

//--------------------------------------------------------

static void on_OpenClose(int, void*);

static void on_ErodeDilate(int, void*);

static void on_TopBlackHat(int, void*);

int main()
{

    //载入原图
    g_srcImage = imread("1.jpg");
    if (!g_srcImage.data)
    {
        printf("读取srcImage错误~！\n");
        return false;
    }

    //显示原始图
    namedWindow("【原始图】");
    imshow("【原始图】", g_srcImage);

    //创建三个窗口
    namedWindow("【开运算/闭运算】", 1);
    namedWindow("【腐蚀/膨胀】", 1);
    namedWindow("【顶帽/黑帽】", 1);

    //参数幅值
    g_nOpenCloseNum = 9;
    g_nErodeDilateNum = 9;
    g_nTopBlackHatNum = 2;

    //创建轨迹条
    createTrackbar("迭代值", "【开运算/闭运算】", &g_nOpenCloseNum, g_nMaxIterationNum * 2 + 1, on_OpenClose);
    createTrackbar("迭代值", "【腐蚀/膨胀】", &g_nErodeDilateNum, g_nMaxIterationNum * 2 + 1, on_ErodeDilate);
    createTrackbar("迭代值", "【顶帽/黑帽】", &g_nTopBlackHatNum, g_nMaxIterationNum * 2 + 1, on_TopBlackHat);

    //轮询获取信息
    while (1)
    {
        int c;
        //执行回调函数
        on_OpenClose(g_nOpenCloseNum, 0);
        on_ErodeDilate(g_nErodeDilateNum, 0);
        on_TopBlackHat(g_nTopBlackHatNum, 0);
        //获取按键
        c = waitKey(0);

        if ((char)c == 'q' || (char)c == 27)
        {
            break;
        }
        //按下键盘按键1 使用椭圆elliptic结构元素MORPH_ELLIPSE
        if ((char)c == 49)
        {
            g_nElementShape = MORPH_ELLIPSE;
        }
        else if ((char)c == 50) //按键2
        {
            g_nElementShape = MORPH_RECT;
        }
        else if ((char)c == 51)
        {
            g_nElementShape = MORPH_CROSS;
        }
        else if ((char)c == ' ')
        {
            g_nElementShape = (g_nElementShape + 1) % 3;
        }
    }
    return 0;
}
//-------------------【on_OpenClose()函数】-------------------

//  描述：开运算/闭运算窗口的回调函数

//----------------------------------------------------------

static void on_OpenClose(int, void*)
{

    //偏移量
    int offset = g_nOpenCloseNum - g_nMaxIterationNum;
    int Absolute_offset = offset > 0 ? offset : -offset;    //绝对值
    Mat element = getStructuringElement(g_nElementShape, Size(Absolute_offset * 2 + 1, Absolute_offset * 2 + 1), Point(Absolute_offset, Absolute_offset));
    if (offset < 0)
    {
        morphologyEx(g_srcImage, g_dstImage, MORPH_OPEN, element);
    }
    else
    {
        morphologyEx(g_srcImage, g_dstImage, MORPH_CLOSE, element);
    }
    imshow("【开运算/闭运算】", g_dstImage);
}

//-------------------------【on_ErodeDilate()函数】------------

//  描述:腐蚀膨胀的回调函数

//------------------------------------------------------------

static void on_ErodeDilate(int, void*)
{

    //偏移量
    int offset = g_nErodeDilateNum - g_nMaxIterationNum;
    int Absolute_offset = offset > 0 ? offset : -offset;    //绝对值
    Mat element = getStructuringElement(g_nElementShape, Size(Absolute_offset * 2 + 1, Absolute_offset * 2 + 1), Point(Absolute_offset, Absolute_offset));
    if (offset < 0)
    {
        erode(g_srcImage, g_dstImage, element);
    }
    else
    {
        dilate(g_srcImage, g_dstImage, element);
    }
    imshow("【腐蚀/膨胀】", g_dstImage);
}

//------------------------【on_TopBlackHat()函数】--------------

//  描述：顶帽/黑帽的回调函数

//-------------------------------------------------------------
static void on_TopBlackHat(int, void*)
{

    //偏移量
    int offset = g_nTopBlackHatNum - g_nMaxIterationNum;
    int Absolute_offset = offset > 0 ? offset : -offset;    //绝对值
    Mat element = getStructuringElement(g_nElementShape, Size(Absolute_offset * 2 + 1, Absolute_offset * 2 + 1), Point(Absolute_offset, Absolute_offset));
    if (offset < 0)
    {
        morphologyEx(g_srcImage, g_dstImage, MORPH_TOPHAT, element);
    }
    else
    {
        morphologyEx(g_srcImage, g_dstImage, MORPH_BLACKHAT, element);
    }
    imshow("【顶帽/黑帽】", g_dstImage);
}
## 运行结果
![](picture/project48-1.png)
![](picture/project48-2.png)
![](picture/project48-3.png)
![](picture/project48-4.png)
![](picture/project48-5.png)
![](picture/project48-6.png)
![](picture/project48-7.png)

# 漫水填充算法：floodFill函数
## 笔记
在OpenCV中，漫水填充算法由floodFill函数实现，其作用是用我们指定的颜色从种子点开始填充一个连接域。连通性由像素值的接近程度来衡量。OpenCV2.X有两个C++重写版本的floodFill。
第一个版本的floodFill：
![](picture/第一个版本的floodFill.png)

第二个版本的floodFill
![](picture/第二个版本的floodFill.png)
下面是一起介绍的参数详解。除了第二个参数外，其他的参数都是共用的。

第一个参数，InputOutputArray类型的image, 输入/输出1通道或3通道，8位或浮点图像，具体参数由之后的参数具体指明。

第二个参数， InputOutputArray类型的mask，这是第二个版本的floodFill独享的参数，表示操作掩模,。它应该为单通道、8位、长和宽上都比输入图像 image 大两个像素点的图像。第二个版本的floodFill需要使用以及更新掩膜，所以这个mask参数我们一定要将其准备好并填在此处。需要注意的是，漫水填充不会填充掩膜mask的非零像素区域。例如，一个边缘检测算子的输出可以用来作为掩膜，以防止填充到边缘。同样的，也可以在多次的函数调用中使用同一个掩膜，以保证填充的区域不会重叠。另外需要注意的是，掩膜mask会比需填充的图像大，所以 mask 中与输入图像(x,y)像素点相对应的点的坐标为(x+1,y+1)。

第三个参数，Point类型的seedPoint，漫水填充算法的起始点。

第四个参数，Scalar类型的newVal，像素点被染色的值，即在重绘区域像素的新值。

第五个参数，Rect*类型的rect，有默认值0，一个可选的参数，用于设置floodFill函数将要重绘区域的最小边界矩形区域。

第六个参数，Scalar类型的loDiff，有默认值Scalar( )，表示当前观察像素值与其部件邻域像素值或者待加入该部件的种子像素之间的亮度或颜色之负差（lower brightness/color difference）的最大值。

第七个参数，Scalar类型的upDiff，有默认值Scalar( )，表示当前观察像素值与其部件邻域像素值或者待加入该部件的种子像素之间的亮度或颜色之正差（lower brightness/color difference）的最大值。

第八个参数，int类型的flags，操作标志符，此参数包含三个部分，比较复杂，我们一起详细看看。

•低八位（第0~7位）用于控制算法的连通性，可取4 (4为缺省值) 或者 8。如果设为4，表示填充算法只考虑当前像素水平方向和垂直方向的相邻点；如果设为 8，除上述相邻点外，还会包含对角线方向的相邻点。

•高八位部分（16~23位）可以为0 或者如下两种选项标识符的组合：
FLOODFILL_FIXED_RANGE - 如果设置为这个标识符的话，就会考虑当前像素与种子像素之间的差，否则就考虑当前像素与其相邻像素的差。也就是说，这个范围是浮动的。
FLOODFILL_MASK_ONLY - 如果设置为这个标识符的话，函数不会去填充改变原始图像 (也就是忽略第三个参数newVal), 而是去填充掩模图像（mask）。这个标识符只对第二个版本的floodFill有用，因第一个版本里面压根就没有mask参数。

•中间八位部分，上面关于高八位FLOODFILL_MASK_ONLY标识符中已经说的很明显，需要输入符合要求的掩码。Floodfill的flags参数的中间八位的值就是用于指定填充掩码图像的值的。但如果flags中间八位的值为0，则掩码会用1来填充。

而所有flags可以用or操作符连接起来，即“|”。例如，如果想用8邻域填充，并填充固定像素值范围，填充掩码而不是填充源图像，以及设填充值为38，那么输入的参数是这样：
flags=8 | FLOODFILL_MASK_ONLY | FLOODFILL_FIXED_RANGE | （38<<8） 

## 代码
#include <opencv2/opencv.hpp>    
#include <opencv2/imgproc/imgproc.hpp>    

//-----------------------------------【命名空间声明部分】------------------------------ 

//      描述：包含程序所使用的命名空间    

//----------------------------------------------------------------------------------- 
   
using namespace cv;

//-----------------------------------【main( )函数】----------------------------------  

//      描述：控制台应用程序的入口函数，我们的程序从这里开始    

//-----------------------------------------------------------------------------------

int main()
{

	Mat src = imread("1.jpg");
	imshow("【原始图】", src);
	Rect ccomp;
	floodFill(src, Point(10, 10), Scalar(155, 255, 55), &ccomp, Scalar(10, 10, 10), Scalar(10, 10, 10));
	imshow("【效果图】", src);
	waitKey(0);
	return 0;
}
## 运行结果
![](picture/project49.png)

 # 综合示例：漫水填充
 ## 代码

//---------------------------------【头文件、命名空间包含部分】----------------------------

//		描述：包含程序所使用的头文件和命名空间

//----------------------------------------------------------------------------------------

#include "opencv2/imgproc/imgproc.hpp"

#include "opencv2/highgui/highgui.hpp"

#include <iostream>

using namespace cv;

using namespace std;


//-----------------------------------【全局变量声明部分】------------------------------  

//      描述：全局变量声明  
//----------------------------------------------------------------------------------  
Mat g_srcImage, g_dstImage, g_grayImage, g_maskImage;//定义原始图、目标图、灰度图、掩模图

int g_nFillMode = 1;//漫水填充的模式

int g_nLowDifference = 20, g_nUpDifference = 20;//负差最大值、正差最大值

int g_nConnectivity = 4;//表示floodFill函数标识符低八位的连通值

int g_bIsColor = true;//是否为彩色图的标识符布尔值

bool g_bUseMask = false;//是否显示掩膜窗口的布尔值

int g_nNewMaskVal = 255;//新的重新绘制的像素值


//-----------------------------------【ShowHelpText( )函数】-----------------------

//      描述：输出一些帮助信息  

//----------------------------------------------------------------------------  
static void ShowHelpText()
{

	//输出欢迎信息和OpenCV版本
	printf("\n\n\t\t\t非常感谢购买《OpenCV3编程入门》一书！\n");
	printf("\n\n\t\t\t此为本书OpenCV3版的第50个配套示例程序\n");
	printf("\n\n\t\t\t   当前使用的OpenCV版本为：" CV_VERSION);
	printf("\n\n  ----------------------------------------------------------------------------\n");

	//输出一些帮助信息  
	printf("\n\n\t欢迎来到漫水填充示例程序~");
	printf("\n\n\t本示例根据鼠标选取的点搜索图像中与之颜色相近的点，并用不同颜色标注。");

	printf("\n\n\t按键操作说明: \n\n"
		"\t\t鼠标点击图中区域- 进行漫水填充操作\n"
		"\t\t键盘按键【ESC】- 退出程序\n"
		"\t\t键盘按键【1】-  切换彩色图/灰度图模式\n"
		"\t\t键盘按键【2】- 显示/隐藏掩膜窗口\n"
		"\t\t键盘按键【3】- 恢复原始图像\n"
		"\t\t键盘按键【4】- 使用空范围的漫水填充\n"
		"\t\t键盘按键【5】- 使用渐变、固定范围的漫水填充\n"
		"\t\t键盘按键【6】- 使用渐变、浮动范围的漫水填充\n"
		"\t\t键盘按键【7】- 操作标志符的低八位使用4位的连接模式\n"
		"\t\t键盘按键【8】- 操作标志符的低八位使用8位的连接模式\n\n");
}


//-----------------------------------【onMouse( )函数】--------------------------------------  

//      描述：鼠标消息onMouse回调函数

//-------------------------------------------------------------------------------------

static void onMouse(int event, int x, int y, int, void*)
{

	// 若鼠标左键没有按下，便返回
	//此句代码的OpenCV2版为：
	//if( event != CV_EVENT_LBUTTONDOWN )
	//此句代码的OpenCV3版为：
	if (event != EVENT_LBUTTONDOWN)
		return;

	//-------------------【<1>调用floodFill函数之前的参数准备部分】---------------
	Point seed = Point(x, y);
	int LowDifference = g_nFillMode == 0 ? 0 : g_nLowDifference;//空范围的漫水填充，此值设为0，否则设为全局的g_nLowDifference
	int UpDifference = g_nFillMode == 0 ? 0 : g_nUpDifference;//空范围的漫水填充，此值设为0，否则设为全局的g_nUpDifference

	//标识符的0~7位为g_nConnectivity，8~15位为g_nNewMaskVal左移8位的值，16~23位为CV_FLOODFILL_FIXED_RANGE或者0。
	//此句代码的OpenCV2版为：
	//int flags = g_nConnectivity + (g_nNewMaskVal << 8) +(g_nFillMode == 1 ? CV_FLOODFILL_FIXED_RANGE : 0);
	//此句代码的OpenCV3版为：
	int flags = g_nConnectivity + (g_nNewMaskVal << 8) + (g_nFillMode == 1 ? FLOODFILL_FIXED_RANGE : 0);

	//随机生成bgr值
	int b = (unsigned)theRNG() & 255;//随机返回一个0~255之间的值
	int g = (unsigned)theRNG() & 255;//随机返回一个0~255之间的值
	int r = (unsigned)theRNG() & 255;//随机返回一个0~255之间的值
	Rect ccomp;//定义重绘区域的最小边界矩形区域

	Scalar newVal = g_bIsColor ? Scalar(b, g, r) : Scalar(r * 0.299 + g * 0.587 + b * 0.114);//在重绘区域像素的新值，若是彩色图模式，取Scalar(b, g, r)；若是灰度图模式，取Scalar(r*0.299 + g*0.587 + b*0.114)

	Mat dst = g_bIsColor ? g_dstImage : g_grayImage;//目标图的赋值
	int area;

	//--------------------【<2>正式调用floodFill函数】-----------------------------
	if (g_bUseMask)
	{
		//此句代码的OpenCV2版为：
		//threshold(g_maskImage, g_maskImage, 1, 128, CV_THRESH_BINARY);
		//此句代码的OpenCV3版为：
		threshold(g_maskImage, g_maskImage, 1, 128, THRESH_BINARY);
		area = floodFill(dst, g_maskImage, seed, newVal, &ccomp, Scalar(LowDifference, LowDifference, LowDifference),
			Scalar(UpDifference, UpDifference, UpDifference), flags);
		imshow("mask", g_maskImage);
	}
	else
	{
		area = floodFill(dst, seed, newVal, &ccomp, Scalar(LowDifference, LowDifference, LowDifference),
			Scalar(UpDifference, UpDifference, UpDifference), flags);
	}

	imshow("效果图", dst);
	cout << area << " 个像素被重绘\n";
}


//-----------------------------------【main( )函数】------------------------------------- 

//      描述：控制台应用程序的入口函数，我们的程序从这里开始  

//------------------------------------------------------------------------------ 

int main(int argc, char** argv)
{

	//改变console字体颜色  
	system("color 2F");

	//载入原图
	g_srcImage = imread("1.jpg", 1);

	if (!g_srcImage.data) { printf("读取图片image0错误~！ \n"); return false; }

	//显示帮助文字
	ShowHelpText();

	g_srcImage.copyTo(g_dstImage);//拷贝源图到目标图
	cvtColor(g_srcImage, g_grayImage, COLOR_BGR2GRAY);//转换三通道的image0到灰度图
	g_maskImage.create(g_srcImage.rows + 2, g_srcImage.cols + 2, CV_8UC1);//利用image0的尺寸来初始化掩膜mask

	//此句代码的OpenCV2版为：
	//namedWindow( "效果图",CV_WINDOW_AUTOSIZE );
	//此句代码的OpenCV2版为：
	namedWindow("效果图", WINDOW_AUTOSIZE);


	//创建Trackbar
	createTrackbar("负差最大值", "效果图", &g_nLowDifference, 255, 0);
	createTrackbar("正差最大值", "效果图", &g_nUpDifference, 255, 0);

	//鼠标回调函数
	setMouseCallback("效果图", onMouse, 0);

	//循环轮询按键
	while (1)
	{
		//先显示效果图
		imshow("效果图", g_bIsColor ? g_dstImage : g_grayImage);

		//获取键盘按键
		int c = waitKey(0);
		//判断ESC是否按下，若按下便退出
		if ((c & 255) == 27)
		{
			cout << "程序退出...........\n";
			break;
		}

		//根据按键的不同，进行各种操作
		switch ((char)c)
		{
			//如果键盘“1”被按下，效果图在在灰度图，彩色图之间互换
		case '1':
			if (g_bIsColor)//若原来为彩色，转为灰度图，并且将掩膜mask所有元素设置为0
			{
				cout << "键盘“1”被按下，切换彩色/灰度模式，当前操作为将【彩色模式】切换为【灰度模式】\n";
				cvtColor(g_srcImage, g_grayImage, COLOR_BGR2GRAY);
				g_maskImage = Scalar::all(0);	//将mask所有元素设置为0
				g_bIsColor = false;	//将标识符置为false，表示当前图像不为彩色，而是灰度
			}
			else//若原来为灰度图，便将原来的彩图image0再次拷贝给image，并且将掩膜mask所有元素设置为0
			{
				cout << "键盘“1”被按下，切换彩色/灰度模式，当前操作为将【彩色模式】切换为【灰度模式】\n";
				g_srcImage.copyTo(g_dstImage);
				g_maskImage = Scalar::all(0);
				g_bIsColor = true;//将标识符置为true，表示当前图像模式为彩色
			}
			break;
			//如果键盘按键“2”被按下，显示/隐藏掩膜窗口
		case '2':
			if (g_bUseMask)
			{
				destroyWindow("mask");
				g_bUseMask = false;
			}
			else
			{
				namedWindow("mask", 0);
				g_maskImage = Scalar::all(0);
				imshow("mask", g_maskImage);
				g_bUseMask = true;
			}
			break;
			//如果键盘按键“3”被按下，恢复原始图像
		case '3':
			cout << "按键“3”被按下，恢复原始图像\n";
			g_srcImage.copyTo(g_dstImage);
			cvtColor(g_dstImage, g_grayImage, COLOR_BGR2GRAY);
			g_maskImage = Scalar::all(0);
			break;
			//如果键盘按键“4”被按下，使用空范围的漫水填充
		case '4':
			cout << "按键“4”被按下，使用空范围的漫水填充\n";
			g_nFillMode = 0;
			break;
			//如果键盘按键“5”被按下，使用渐变、固定范围的漫水填充
		case '5':
			cout << "按键“5”被按下，使用渐变、固定范围的漫水填充\n";
			g_nFillMode = 1;
			break;
			//如果键盘按键“6”被按下，使用渐变、浮动范围的漫水填充
		case '6':
			cout << "按键“6”被按下，使用渐变、浮动范围的漫水填充\n";
			g_nFillMode = 2;
			break;
			//如果键盘按键“7”被按下，操作标志符的低八位使用4位的连接模式
		case '7':
			cout << "按键“7”被按下，操作标志符的低八位使用4位的连接模式\n";
			g_nConnectivity = 4;
			break;
			//如果键盘按键“8”被按下，操作标志符的低八位使用8位的连接模式
		case '8':
			cout << "按键“8”被按下，操作标志符的低八位使用8位的连接模式\n";
			g_nConnectivity = 8;
			break;
		}
	}

	return 0;
}

 ## 运行结果
 ![](picture/project50.png)


 # 尺寸调整：resize（）函数的使用
 ## 笔记
 esize( )为OpenCV中专职调整图像大小的函数。此函数将源图像精确地转换为指定尺寸的目标图像。如果源图像中设置了ROI（Region Of Interest ，感兴趣区域），那么resize( )函数会对源图像的ROI区域进行调整图像尺寸的操作，来输出到目标图像中。若目标图像中已经设置ROI区域，不难理解resize( )将会对源图像进行尺寸调整并填充到目标图像的ROI中。很多时候，我们并不用考虑第二个参数dst的初始图像尺寸和类型（即直接定义一个Mat类型，不用对其初始化），因为其尺寸和类型可以由src,dsize,fx和fy这几个参数来确定。\

 函数原型
 ![](picture/resize函数.png)
第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。

第二个参数，OutputArray类型的dst，输出图像，当其非零时，有着dsize（第三个参数）的尺寸，或者由src.size()计算出来。

第三个参数，Size类型的dsize，输出图像的大小;如果它等于零，由下式进行计算：
其中，dsize，fx，fy都不能为0。

第四个参数，double类型的fx，沿水平轴的缩放系数，有默认值0，且当其等于0时，由下式进行计算：

第五个参数，double类型的fy，沿垂直轴的缩放系数，有默认值0，且当其等于0时，由下式进行计算：

第六个参数，int类型的interpolation，用于指定插值方式，默认为INTER_LINEAR（线性插值）。
可选的插值方式如下：

INTER_NEAREST - 最近邻插值

INTER_LINEAR - 线性插值（默认值）

INTER_AREA - 区域插值（利用像素区域关系的重采样插值）

INTER_CUBIC –三次样条插值（超过4×4像素邻域内的双三次插值）

INTER_LANCZOS4 -Lanczos插值（超过8×8像素邻域的Lanczos插值）

若要缩小图像，一般情况下最好用CV_INTER_AREA来插值，而若要放大图像，一般情况下最好用CV_INTER_CUBIC（效率不高，慢，不推荐使用）或CV_INTER_LINEAR（效率较高，速度较快，推荐使用）。 

## 代码
//--------------【头文件、命名空间包含部分】---------

//  描述 : 包含程序所依赖的头文件和命名空间

// ---------------------------------------------------

#include <opencv2/opencv.hpp>

#include <opencv2/imgproc/imgproc.hpp>

using namespace cv ;

//---------------------【main()函数】-------------------

//   描述:控制台应用程序的入口函数，我们的程序从这里开始

//-----------------------------------------------------

int main()
{

	//载入原始图
	Mat srcImage = imread("1.jpg");//工程目录下应该有一张名为1.jpg 的素材图
	Mat tmpImage, dstImage1, dstImage2;//临时变量和目标图的定义
	tmpImage = srcImage;//将原始图赋给临时

	//显示原始图
	imshow("【原始图】", srcImage);

	//进行尺寸调整操作
	resize(tmpImage, dstImage1, Size(tmpImage.cols / 2, tmpImage.rows / 2), (0, 0), (0, 0), 3);
	resize(tmpImage, dstImage2, Size(tmpImage.cols * 2, tmpImage.rows * 2), (0, 0), (0, 0), 3);
	
	//显示效果图
	imshow("【效果图】之一", dstImage1);
	imshow("【效果图】之二", dstImage2);
	
	waitKey(0);
	return 0;
}
## 运行结果
![](picture/project51.png)

# 向上采样图像金字塔：pyrUp()函数的使用
## 笔记
函数原型

![](picture/pyrUp函数.png)
第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。

第二个参数，OutputArray类型的dst，输出图像，和源图片有一样的尺寸和类型。

第三个参数，const Size&类型的dstsize，输出图像的大小;有默认值Size()，即默认情况下，由Size（src.cols*2，src.rows*2）来进行计算，且一直需要满足下列条件：

![](picture/条件.png)

第四个参数，int类型的borderType，又来了，边界模式，一般我们不用去管它。
pyrUp函数执行高斯金字塔的采样操作，其实它也可以用于拉普拉斯金字塔的。首先，它通过插入可为零的行与列，对源图像进行向上取样操作，然后将结果与pyrDown（）乘以4的内核做卷积，就是这样。直接看完整的示例程序。 

## 代码
//---------------------------------【头文件、命名空间包含部分】----------------------------

//		描述：包含程序所使用的头文件和命名空间

//--------------------------------------------------------------------------------------
#include <opencv2/opencv.hpp>

#include <opencv2/imgproc/imgproc.hpp>

using namespace cv;

//-----------------------------------【main( )函数】------------------------------------------

//		描述：控制台应用程序的入口函数，我们的程序从这里开始

//----------------------------------------------------------------------------------
int main( )
{

	//载入原始图   
	Mat srcImage = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图
	Mat tmpImage,dstImage;//临时变量和目标图的定义
	tmpImage=srcImage;//将原始图赋给临时变量

	//显示原始图  
	imshow("【原始图】", srcImage);  
	//进行向上取样操作
	pyrUp( tmpImage, dstImage, Size( tmpImage.cols*2, tmpImage.rows*2 ) );
	//显示效果图  
	imshow("【效果图】", dstImage);  

	waitKey(0);  
	return 0;  
}
## 运行结果
![](picture/project52.png)

# 向上采样图像金字塔：pyrDown()函数的使用

## 笔记
函数原型
![](picture/pyrDown函数.png)

第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。
第二个参数，OutputArray类型的dst，输出图像，和源图片有一样的尺寸和类型。
第三个参数，const Size&类型的dstsize，输出图像的大小;有默认值Size()，即默认情况下，由Size Size((src.cols+1)/2, (src.rows+1)/2)来进行计算，且一直需要满足下列条件：

![](picture/条件2.png)

该pyrDown函数执行了高斯金字塔建造的向下采样的步骤。首先，它将源图像与如下内核做卷积运算：

![](picture/卷积运算.png)

接着，它便通过对图像的偶数行和列做插值来进行向下采样操作。依然是看看完整的示例程序。 

## 代码
//---------------------------------【头文件、命名空间包含部分】----------------------------

//		描述：包含程序所使用的头文件和命名空间

//--------------------------------------------------------------------------------------------

#include <opencv2/opencv.hpp>

#include <opencv2/imgproc/imgproc.hpp>

using namespace cv;

//-----------------------------------【main( )函数】-----------------------------------------

//		描述：控制台应用程序的入口函数，我们的程序从这里开始

//---------------------------------------------------------------------------------

int main()
{

	//载入原始图   
	Mat srcImage = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图
	Mat tmpImage, dstImage;//临时变量和目标图的定义
	tmpImage = srcImage;//将原始图赋给临时变量

	//显示原始图  
	imshow("【原始图】", srcImage);
	//进行向下取样操作
	pyrDown(tmpImage, dstImage, Size(tmpImage.cols / 2, tmpImage.rows / 2));
	//显示效果图  
	imshow("【效果图】", dstImage);

	waitKey(0);

	return 0;
}

## 运行结果
![](picture/project53.png)
